#!/usr/bin/env python3

"""
Script to automatically setup a fresh new Linux/MacOS system (or VM).

This script should ONLY be used after installing a fresh new OS on a new machine or
inside a VM to setup a development environment automatically. The script will install
necessary tools like Code Editors, package managers and more before setting up their
configuration files automatically.

USAGE: To use the script, run the following command (its not ready for usage yet);

curl -fsSL https://raw.githubusercontent.com/<username>/<repository>/path/to/script \
    | python3 - --dry-run

NOTE: The script is designed to be subjective, hence it is RECOMMENDED to NOT invoke it
without understanding the context of the contents! Please read through the script or
reach out to the author for clarification on what certain parts of the script does.

DISCLAIMER: The script IS NOT TESTED and there is no guranteed it works properly!

Author: Somraj Saha <somraj.saha@jarmos.dev>
License: MIT (see the LICENSE document for more info on this regards)
"""

# TODO: Make use of the logging module instead of useless print statements

import platform
import subprocess
import time
from argparse import ArgumentParser, Namespace
from enum import StrEnum, unique
from io import BytesIO
from pathlib import Path
from urllib.request import urlopen
from zipfile import ZipFile

# Fetch and store the OS name to be used later on in the script
OS_NAME = platform.freedesktop_os_release().get("NAME")

# Set the global default script runtime behaviour to be a simulation
DRY_RUN = True


@unique
class MessageLabel(StrEnum):

    """Message labels with appropriate terminal colours to showcase its importance."""

    ERROR = "\033[0;31m[ERROR]\033[0m"
    SUCCESS = "\033[0;32m[SUCCESS]\033[0m"
    WARNING = "\033[0;33m[WARNING]\033[0m"
    INFO = "\033[0;34m[INFO]\033[0m"

    def __str__(self) -> str:
        """Easier representation of the Enum Object's values with print statements."""
        return self.value


def argument_parser() -> Namespace:
    """Parse the list of arguments passed to the script and return them."""
    parser = ArgumentParser(
        description="Automation script to setup a dev environment on a new machine!"
    )

    parser.add_argument(
        "--dry-run",
        required=False,
        help="Enable the script without making serious changes to the system.",
        action="store_true",
    )

    return parser.parse_args()


def system_update_simulation() -> None:
    """Simulate a system update (when the "dry_run" arguments are passed)."""
    print("Simulating system updates...")

    # Print a bunch of dots across 10 lines for roughly around 30 secs
    for _ in range(10):
        print("...")
        time.sleep(3)

    print("System upgrade simulation complete...")


def is_tool_installed(tool: str) -> bool:
    """
    Check if a tool is installed and executable.

    tool (String): The name of the tool to check for its availability
    """
    try:
        subprocess.run(
            [tool, "--version"],
            check=True,
            stderr=subprocess.PIPE,
            stdout=subprocess.PIPE,
        )
        return True
    except subprocess.CalledProcessError as error:
        raise error


def run_apt_updates(dry_run: bool) -> None:
    """
    Run APT to update a Debian/Ubuntu system and perform some cleanup actions.

    dry_run (boolean): Flag to configure the apt-get statements to run either in dry
        mode or not.
    """
    if not dry_run:
        subprocess.run(["sudo", "apt-get", "update"])
        subprocess.run(["sudo", "apt-get", "upgrade", "--assume-yes"])
        subprocess.run(["sudo", "apt-get", "autoremove", "--purge"])
    else:
        system_update_simulation()


def run_macos_updates(dry_run: bool) -> None:
    """
    Automate MacOS system updates.

    dry_run (boolean): Flag to configure the MacOS system update to run either in dry
        mode or not.
    """
    if not dry_run:
        try:
            subprocess.run(["sudo", "softwareupdate", "-i", "-a"])
        except subprocess.CalledProcessError as error:
            print("MacOS system update failed...")
            print(error)
    else:
        system_update_simulation()


def run_system_updates(dry_run: bool = DRY_RUN) -> None:
    """
    Detect the Operating System name and run some system updates on it.

    dry_run (boolean): Defaults to True which configures the function to run system
        updates in dry mode explicitly.
    """
    if platform.system() == "Linux":
        match OS_NAME:
            case "Ubuntu" | "Debian":
                run_apt_updates(dry_run=dry_run)
            case _:
                print("Failed to identify the OS...aborting system updates!")
    elif platform.system() == "MacOS":
        run_macos_updates(dry_run=dry_run)
    else:
        print("Failed to identify the platform!")


def install_system_essentials(dry_run: bool = DRY_RUN) -> None:
    """
    Install certain essentials necessary for proper functioning of the system.

    dry_run (Boolean): Optional flag to either run system updates based on the
        identified OS.
    """
    if platform.system() == "Linux":
        match OS_NAME:
            case "Ubuntu" | "Debian":
                if not dry_run:
                    try:
                        subprocess.run(
                            [
                                "sudo",
                                "apt-get",
                                "install",
                                "curl",
                                "git",
                                "--yes",
                                "--no-install-recommends",
                            ]
                        )
                    except subprocess.CalledProcessError as error:
                        print(error)
                else:
                    subprocess.run(
                        [
                            "sudo",
                            "apt-get",
                            "install",
                            "curl",
                            "git",
                            "--yes",
                            "--no-install-recommends",
                            "--dry-run",
                        ]
                    )
            case _:
                print("Failed to identify OS...aborting!")
    else:
        print("Unknown OS...aborting!")


def install_homebrew(dry_run: bool = DRY_RUN) -> None:
    """
    Install HomeBrew on MacOS and Ubuntu/Debian systems.

    dry_run (Boolean): Optional flag to simulate Homebrew installtion.
    """
    homebrew_installation_url = (
        "https://raw.githubusercontent.com/Homebrew/install/master/install.sh"
    )
    curl_command = (
        f"curl --fail --silent --show-error --location ${homebrew_installation_url}"
    )

    if not dry_run:
        # Install Homebrew only for MacOS and Ubuntu/Debian systems
        if platform.system() == "MacOS" or platform.system() == "Linux":
            try:
                subprocess.run(
                    ["NONINTERACTIVE=1 ", "/bin/bash", "-c", f'$"({curl_command})"']
                )
            except subprocess.CalledProcessError as error:
                print(f"Failed to install Homebrew: {error}")
        else:
            pass
    else:
        # TODO: Refactor the "system_update_simulation" to consider a Homebrew
        # installation as well
        print("Simulating Homebrew installation...")


def install_fonts(dry_run: bool = DRY_RUN) -> None:
    """
    Install certain fonts and make them available for use in the system.

    dry_run (Boolean): Optional flag to simulate installation of the system fonts.
    """
    url = "https://github.com/ryanoasis/nerd-fonts/releases/download/v3.0.2/CascadiaCode.zip"
    fonts_dir = Path(f"{Path.home()}/.fonts")

    if not platform.system() == "Linux" or platform.system() == "MacOS":
        print("Failed to identify OS...skipping fonts setup!")
    else:
        if not dry_run:
            with urlopen(url=url) as res:
                print("Downloading fonts...please wait!")

                # Store the buffered contents from the HTTPS response in a variable
                contents = BytesIO(res.read())

                # Create a zipped file from the buffered contents
                zipfile = ZipFile(contents)

                # If the "~/.fonts" directory doesn't exists, create it before
                # extracting the zipped contents
                if not fonts_dir.exists() and not fonts_dir.is_dir():
                    Path.mkdir(fonts_dir)

                # Extract the zipped contents to the "~/.fonts" directory
                zipfile.extractall(fonts_dir)

                # Refresh the font cache for the OS to know where to look for the new
                # fonts
                try:
                    subprocess.run(["fc-cache", "--force"])
                except subprocess.CalledProcessError as error:
                    print(error)

                print("Fonts download and setup complete!")
        else:
            # TODO: Write the logic to run a simulation of fonts installation
            print("Simulating fonts downloading and installation...")


def install_brew_packages(dry_run: bool = DRY_RUN) -> None:
    """
    Install Homebrew packages.

    dry_run (Boolean): Optional flag to simulate Homebrew formulae installation.
    """
    taps = (
        "eth-p/software",
        "go-task/tap",
        "homebrew/bundle",
        "homebrew/core",
        "xo/xo",
    )

    casks = ("visual-studio-code", "spotify", "discord", "inkscape", "dbeaverlite")

    formulae = (
        "azure-cli",
        "btop",
        "cmatrix",
        "cookiecutter",
        "exa",
        "gcc",
        "gh",
        "httpie",
        "lua@5.1",
        "mdbook",
        "neofetch",
        "neovim",
        "oci-cli",
        "poetry",
        "pre-commit",
        "ripgrep",
        "rust",
        "starship",
        "shellcheck",
        "usql",
        "zsh",
    )

    # INFO: Check if Homebrew is installed and invocable, else raise an error and log it
    if is_tool_installed("brew"):
        if not dry_run:
            print(taps, casks, formulae)

            # INFO: Install "taps" for Homebrew to fetch the packages (formulae) from
            for tap in taps:
                try:
                    subprocess.run(["brew", "install", tap])
                except subprocess.CalledProcessError as error:
                    print(error)

            # INFO: Install "formulae" (the packages) using Homebrew for both Linux and
            # MacOS systems
            for formula in formulae:
                try:
                    subprocess.run(["brew", "install", formula])
                except subprocess.CalledProcessError as error:
                    print(error)

            # INFO: Installation of "casks" (GUI tools) are ONLY supported on MacOS!
            if platform.system() == "MacOS":
                for cask in casks:
                    try:
                        subprocess.run(["brew", "install", cask])
                    except subprocess.CalledProcessError as error:
                        print(error)

        else:
            # TODO: Refactor and write simulation function instead
            print("Simulating Homebrew package installation...")


def install_flatpak(dry_run: bool = DRY_RUN) -> None:
    """
    Install Flatpak if its not available on Linux distros.

    dry_run (Boolean): Simulate Flatpak installation for the system.
    """
    flatpak_repo = "https://flathub.org/repo/flathub.flatpakrepo"

    if not dry_run:
        # INFO: Attempt to install Flatpak if it is not available ONLY on Linux distros
        if platform.system() == "Linux" and not is_tool_installed("flatpak"):
            match OS_NAME:
                case "Ubuntu" | "Debian":
                    try:
                        subprocess.run(["apt-get", "install", "flatpak"])
                    except subprocess.CalledProcessError as error:
                        print(error)
                case _:
                    print("Failed to identify OS...skipping Flatpak installation")
                    pass

            try:
                subprocess.run(
                    ["flatpak", "remote-add", "-if-not-exists", "flathub", flatpak_repo]
                )
            except subprocess.CalledProcessError as error:
                print(error)
    else:
        print("Simulating a dry installation for Flatpak!")


def install_flatpak_packages(dry_run: bool = DRY_RUN) -> None:
    """
    Install Flatpak packages on Linux distros.

    dry_run (Boolean): Simulate installing Flatpak packages on Linux systems.
    """
    packages = (
        "com.calibre_ebook.calibre"
        "com.discordapp.Discord"
        "org.flameshot.Flameshot"
        "com.microsoft.Edge"
        "com.github.KRTirtho.Spotube"
        "com.transmissionbt.Transmission"
        "com.valvesoftware.Steam"
        "com.visualstudio.code"
        "io.dbeaver.DBeaverCommunity"
        "org.wezfurlong.wezterm"
    )

    if not dry_run:
        if is_tool_installed("flatpak"):
            for package in packages:
                try:
                    subprocess.run(
                        ["flatpak", "install", "--assumeyes", "flathub", package]
                    )
                except subprocess.CalledProcessError as error:
                    print(error)
    else:
        print("Simulating a dry installation for Flatpak packages!")


def install_zsh_plugins(dry_run: bool = DRY_RUN) -> None:
    """
    Install ZSH plugins.

    dry_run (Boolean): Flag to optionally simulate installing ZSH plugins.
    """
    # The list of ZSH plugins to install
    plugins = (
        "zsh-users/zsh-syntax-highlighting"
        "zsh-users/zsh-autosuggestions"
        "zsh-users/zsh-completions"
        "le0me55i/zsh-extract"
        "ael-code/zsh-colored-man-pages"
    )

    # The location on the filesystem to store the plugins
    zsh_plugin_dir = Path(f"{Path.home()}/.zsh/plugins")

    # Create the plugins directory if it doesn't already exists
    if not zsh_plugin_dir.exists() and not zsh_plugin_dir.is_dir():
        Path.mkdir(zsh_plugin_dir)

    # Attempt to install the ZSH plugins from GitHub to its respective location
    if not dry_run:
        for plugin in plugins:
            try:
                subprocess.run(
                    ["git", "clone", f"git@github.com{plugin}", zsh_plugin_dir]
                )
            except subprocess.CalledProcessError as error:
                print(error)
    else:
        print("Simulating ZSH plugins installation...")


def setup_dotfiles(dry_run: bool = DRY_RUN) -> None:
    """
    Set up dotfiles for the system.

    dry_run (Boolean): Flat to optionally simulate the dotfiles setup for the system.
    """
    dotfiles_dir = Path(f"{Path.home()}/.dotfiles")

    if not dry_run:
        # INFO: Create the "~/.dotfiles" directory if it doesn't already exists
        if not dotfiles_dir.exists() and not dotfiles_dir.is_dir():
            Path.mkdir(dotfiles_dir)

        # INFO: Attempt to download the dotfiles from the remote repository on GitHub
        try:
            subprocess.run(
                ["git", "clone", "git@github.com:Jarmos-san/dotfiles", dotfiles_dir]
            )
        except subprocess.CalledProcessError as error:
            print(error)

        # INFO: Check if the contents of the ".dotfiles" repository are already
        # symlinked, if yes then attempt to remove the links
        for content in Path.iterdir(dotfiles_dir / "dotfiles"):
            if content.is_symlink():
                content.unlink(missing_ok=True)

        # INFO: Create symlinks of the contents from "~/.dotfiles/dotfiles" directory
        for content in Path.iterdir(dotfiles_dir / "dotfiles"):
            content.symlink_to(
                target=f"{Path.home()}/{content}", target_is_directory=True
            )
    else:
        print("Simulating dotfiles setup...")


def install_docker() -> None:
    """Install Docker for the system."""
    pass


def install_node(dry_run: bool = DRY_RUN) -> None:
    """
    Install Node.js for the system.

    dry_run (Boolean): Flat to simulate Node.js installation on the system.

    INFO: It is necessary to Node.js through the recommended approach instead of
    Homebrew because of issues with TypeScript complaining about the localtion of npm.
    See the folowing issue thread for more information on this regards:
    https://github.com/microsoft/TypeScript/issues/23924
    """
    if not dry_run:
        # TODO: Figure out how to install Node.js using Python
        pass
    else:
        print("Simulating Node.js installation...")


def main() -> None:
    """Entrypoint of the script."""
    args = argument_parser()

    if not args.dry_run:
        run_system_updates(dry_run=False)
        install_homebrew(dry_run=False)
        install_system_essentials(dry_run=False)
        install_fonts(dry_run=False)
        install_brew_packages(dry_run=False)
        install_flatpak(dry_run=False)
        install_flatpak_packages(dry_run=False)
        install_zsh_plugins(dry_run=False)
        setup_dotfiles(dry_run=False)
        install_docker()
        install_node(dry_run=False)
    else:
        print('Running script in "dry" mode...')
        run_system_updates()
        install_homebrew()
        install_system_essentials()
        install_fonts()
        install_brew_packages()
        install_flatpak()
        install_flatpak_packages()
        install_zsh_plugins()
        setup_dotfiles()
        install_docker()
        install_node()


if __name__ == "__main__":
    main()
