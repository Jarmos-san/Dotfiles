#!/usr/bin/env python3

"""
Script to automatically setup a fresh new Linux/MacOS system (or VM).

This script should ONLY be used after installing a fresh new OS on a new machine or
inside a VM to setup a development environment automatically. The script will install
necessary tools like Code Editors, package managers and more before setting up their
configuration files automatically.

USAGE: To use the script, run the following command (its not ready for usage yet);

curl -fsSL https://raw.githubusercontent.com/<username>/<repository>/path/to/script \
    | python3 - --dry-run

NOTE: The script is designed to be subjective, hence it is RECOMMENDED to NOT invoke it
without understanding the context of the contents! Please read through the script or
reach out to the author for clarification on what certain parts of the script does.

DISCLAIMER: The script IS NOT TESTED and there is no guranteed it works properly!

Author: Somraj Saha <somraj.saha@weburz.com>
License: MIT (see the LICENSE document for more info on this regards)
"""

# TODO: Make use of the logging module instead of useless print statements

import platform
import subprocess
import time
from argparse import ArgumentParser, Namespace
from io import BytesIO
from pathlib import Path
from urllib.request import urlopen
from zipfile import ZipFile

# Fetch and store the OS name to be used later on in the script
OS_NAME = platform.freedesktop_os_release().get("NAME")

# Set the global default script runtime behaviour to be a simulation
DRY_RUN = True


def argument_parser() -> Namespace:
    """Parse the list of arguments passed to the script and return them."""
    parser = ArgumentParser(
        description="Automation script to setup a dev environment on a new machine!"
    )

    parser.add_argument(
        "--dry-run",
        required=False,
        help="Enable the script without making serious changes to the system.",
        action="store_true",
    )

    return parser.parse_args()


def system_update_simulation() -> None:
    """Simulate a system update (when the "dry_run" arguments are passed)."""
    print("Simulating system updates...")

    # Print a bunch of dots across 10 lines for roughly around 30 secs
    for _ in range(10):
        print("...")
        time.sleep(3)

    print("System upgrade simulation complete...")


def run_apt_updates(dry_run: bool) -> None:
    """
    Run APT to update a Debian/Ubuntu system and perform some cleanup actions.

    dry_run (boolean): Flag to configure the apt-get statements to run either in dry
                       mode or not.
    """
    if not dry_run:
        subprocess.run(["sudo", "apt-get", "update"])
        subprocess.run(["sudo", "apt-get", "upgrade", "--assume-yes"])
        subprocess.run(["sudo", "apt-get", "autoremove", "--purge"])
    else:
        system_update_simulation()


def run_macos_updates(dry_run: bool) -> None:
    """Automate MacOS system updates."""
    if not dry_run:
        try:
            subprocess.run(["sudo", "softwareupdate", "-i", "-a"])
        except subprocess.CalledProcessError as error:
            print("MacOS system update failed...")
            print(error)
    else:
        system_update_simulation()


def run_system_updates(dry_run: bool = DRY_RUN) -> None:
    """
    Detect the Operating System name and run some system updates on it.

    dry_run (boolean): Defaults to True which configures the function to run system
                       updates in dry mode explicitly.
    """
    if platform.system() == "Linux":
        match OS_NAME:
            case "Ubuntu" | "Debian":
                run_apt_updates(dry_run=dry_run)
            case _:
                print("Failed to identify the OS...aborting system updates!")
    elif platform.system() == "MacOS":
        run_macos_updates(dry_run=dry_run)
    else:
        print("Failed to identify the platform!")


def install_system_essentials(dry_run: bool = DRY_RUN) -> None:
    """Install certain essentials necessary for proper functioning of the system."""
    if platform.system() == "Linux":
        match OS_NAME:
            case "Ubuntu" | "Debian":
                if not dry_run:
                    try:
                        subprocess.run(
                            [
                                "sudo",
                                "apt-get",
                                "install",
                                "curl",
                                "git",
                                "--yes",
                                "--no-install-recommends",
                            ]
                        )
                    except subprocess.CalledProcessError as error:
                        print(error)
                else:
                    subprocess.run(
                        [
                            "sudo",
                            "apt-get",
                            "install",
                            "curl",
                            "git",
                            "--yes",
                            "--no-install-recommends",
                            "--dry-run",
                        ]
                    )
            case _:
                print("Failed to identify OS...aborting!")
    else:
        print("Unknown OS...aborting!")


def install_homebrew(dry_run: bool = DRY_RUN) -> None:
    """Install HomeBrew on MacOS and Ubuntu/Debian systems."""
    homebrew_installation_url = (
        "https://raw.githubusercontent.com/Homebrew/install/master/install.sh"
    )
    curl_command = (
        f"curl --fail --silent --show-error --location ${homebrew_installation_url}"
    )

    if not dry_run:
        # Install Homebrew only for MacOS and Ubuntu/Debian systems
        if platform.system() == "MacOS" or platform.system() == "Linux":
            try:
                subprocess.run(
                    ["NONINTERACTIVE=1 ", "/bin/bash", "-c", f'$"({curl_command})"']
                )
            except subprocess.CalledProcessError as error:
                print(f"Failed to install Homebrew: {error}")
        else:
            pass
    else:
        # TODO: Refactor the "system_update_simulation" to consider a Homebrew
        # installation as well
        print("Simulating Homebrew installation...")


def install_fonts(dry_run: bool = DRY_RUN) -> None:
    """Install certain fonts and make them available for use in the system."""
    url = "https://github.com/ryanoasis/nerd-fonts/releases/download/v3.0.2/CascadiaCode.zip"
    fonts_dir = Path(f"{Path.home()}/.fonts")

    if not platform.system() == "Linux" or platform.system() == "MacOS":
        print("Failed to identify OS...skipping fonts setup!")
    else:
        if not dry_run:
            with urlopen(url=url) as res:
                print("Downloading fonts...please wait!")

                # Store the buffered contents from the HTTPS response in a variable
                contents = BytesIO(res.read())

                # Create a zipped file from the buffered contents
                zipfile = ZipFile(contents)

                # If the "~/.fonts" directory doesn't exists, create it before
                # extracting the zipped contents
                if not fonts_dir.exists() and not fonts_dir.is_dir():
                    Path.mkdir(fonts_dir)

                # Extract the zipped contents to the "~/.fonts" directory
                zipfile.extractall(fonts_dir)

                # Refresh the font cache for the OS to know where to look for the new
                # fonts
                try:
                    subprocess.run(["fc-cache", "--force"])
                except subprocess.CalledProcessError as error:
                    print(error)

                print("Fonts download and setup complete!")
        else:
            # TODO: Write the logic to run a simulation of fonts installation
            print("Simulating fonts downloading and installation...")


def install_brew_packages(dry_run: bool = DRY_RUN) -> None:
    """Install Homebrew packages."""
    taps = (
        "eth-p/software",
        "go-task/tap",
        "homebrew/bundle",
        "homebrew/core",
        "xo/xo",
    )

    casks = ("visual-studio-code", "spotify", "discord", "inkscape", "dbeaverlite")

    formulae = (
        "azure-cli",
        "btop",
        "cmatrix",
        "cookiecutter",
        "exa",
        "fd",
        "gcc",
        "gh",
        "glow",
        "httpie",
        "lua@5.1",
        "mdbook",
        "neofetch",
        "neovim",
        "oci-cli",
        "poetry",
        "pre-commit",
        "ripgrep",
        "rustup-init",
        "starship",
        "shellcheck",
        "stow",
        "usql",
        "zsh",
    )

    # INFO: Check if Homebrew is installed and invocable, else raise an error and log it
    try:
        subprocess.run(["brew", "--version"], check=True)
    except subprocess.CalledProcessError as error:
        raise (error)

    if not dry_run:
        print(taps, casks, formulae)

        # INFO: Install "taps" for Homebrew to fetch the packages (formulae) from
        for tap in taps:
            try:
                subprocess.run(["brew", "install", tap])
            except subprocess.CalledProcessError as error:
                print(error)

        # INFO: Install "formulae" (the packages) using Homebrew for both Linux and
        # MacOS systems
        for formula in formulae:
            try:
                subprocess.run(["brew", "install", formula])
            except subprocess.CalledProcessError as error:
                print(error)

        # INFO: Installation of "casks" (GUI tools) are ONLY supported on MacOS!
        if platform.system() == "MacOS":
            for cask in casks:
                try:
                    subprocess.run(["brew", "install", cask])
                except subprocess.CalledProcessError as error:
                    print(error)

    else:
        # TODO: Refactor and write simulation function instead
        print("Simulating Homebrew package installation...")


def is_flatpak_installed() -> bool:
    """Check if Flatpak is installed or not."""
    try:
        subprocess.run(["flatpak", "--version"], check=True)
        return True
    except subprocess.CalledProcessError as error:
        raise error


def install_flatpak(dry_run: bool = DRY_RUN) -> None:
    """Install Flatpak if its not available on Linux distros."""
    flatpak_repo = "https://flathub.org/repo/flathub.flatpakrepo"

    if not dry_run:
        # INFO: Attempt to install Flatpak if it is not available ONLY on Linux distros
        if platform.system() == "Linux" and not is_flatpak_installed():
            match OS_NAME:
                case "Ubuntu" | "Debian":
                    try:
                        subprocess.run(["apt-get", "install", "flatpak"])
                    except subprocess.CalledProcessError as error:
                        print(error)
                case _:
                    print("Failed to identify OS...skipping Flatpak installation")
                    pass

            try:
                subprocess.run(
                    ["flatpak", "remote-add", "-if-not-exists", "flathub", flatpak_repo]
                )
            except subprocess.CalledProcessError as error:
                print(error)
    else:
        print("Simulating a dry installation for Flatpak!")


def install_flatpak_packages(dry_run: bool = DRY_RUN) -> None:
    """Install Flatpak packages on Linux distros."""
    packages = (
        "com.microsoft.Edge"
        "com.spotify.Client"
        "com.discordapp.Discord"
        "com.transmissionbt.Transmission"
        "org.wezfurlong.wezterm"
        "com.calibre_ebook.calibre"
        "com.valvesoftware.Steam"
        "org.flameshot.Flameshot"
        "com.visualstudio.code"
        "io.dbeaver.DBeaverCommunity"
    )

    if not dry_run:
        if is_flatpak_installed():
            for package in packages:
                try:
                    subprocess.run(
                        ["flatpak", "install", "--assumeyes", "flathub", package]
                    )
                except subprocess.CalledProcessError as error:
                    print(error)
    else:
        print("Simulating a dry installation for Flatpak packages!")


def install_zsh_plugins(dry_run: bool = DRY_RUN) -> None:
    """Install ZSH plugins."""
    # The list of ZSH plugins to install
    plugins = (
        "zsh-users/zsh-syntax-highlighting"
        "zsh-users/zsh-autosuggestions"
        "zsh-users/zsh-completions"
        "le0me55i/zsh-extract"
        "ael-code/zsh-colored-man-pages"
    )

    # The location on the filesystem to store the plugins
    zsh_plugin_dir = Path(f"{Path.home()}/.zsh/plugins")

    # Create the plugins directory if it doesn't already exists
    if not zsh_plugin_dir.exists() and not zsh_plugin_dir.is_dir():
        Path.mkdir(zsh_plugin_dir)

    # Attempt to install the ZSH plugins from GitHub to its respective location
    if not dry_run:
        for plugin in plugins:
            try:
                subprocess.run(
                    ["git", "clone", f"git@github.com{plugin}", zsh_plugin_dir]
                )
            except subprocess.CalledProcessError as error:
                print(error)
    else:
        print("Simulating ZSH plugins installation...")


def setup_dotfiles() -> None:
    """Set up dotfiles for the system."""
    pass


def install_docker() -> None:
    """Install Docker for the system."""
    pass


def install_rust() -> None:
    """Install Rust for the system."""
    pass


def install_node() -> None:
    """Install Node.js for the system."""
    pass


def main() -> None:
    """Entrypoint of the script."""
    args = argument_parser()

    if not args.dry_run:
        run_system_updates(dry_run=False)
        install_homebrew(dry_run=False)
        install_system_essentials(dry_run=False)
        install_fonts(dry_run=False)
        install_brew_packages(dry_run=False)
        install_flatpak(dry_run=False)
        install_flatpak_packages(dry_run=False)
        install_zsh_plugins(dry_run=False)
        setup_dotfiles()
        install_docker()
        install_rust()
        install_node()
    else:
        print('Running script in "dry" mode...')
        run_system_updates()
        install_homebrew()
        install_system_essentials()
        install_fonts()
        install_brew_packages()
        install_flatpak()
        install_flatpak_packages()
        install_zsh_plugins()
        setup_dotfiles()
        install_docker()
        install_rust()
        install_node()


if __name__ == "__main__":
    main()
