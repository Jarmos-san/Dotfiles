#!/usr/bin/env bash
#
# Script to install Neovimulus on a user's local machine automatically.
#
# Author: Somraj Saha
# License: MIT License
# (see https://github.com/Jarmos-san/neovimulus/blob/main/LICENSE for info).

# INFO: Necessary command for all Bash script to execute safely.
# For a detailed explanation, check the following resource:
# https://explainshell.com/explain?cmd=set+-euo+pipefail
set -euo pipefail

# Some colour codes to make the formatted output prettier.
readonly RED="\033[0;31m"
readonly GREEN="\033[0;32m"
readonly YELLOW="\033[0;33m"
readonly BLUE="\033[0;34m"
readonly NOCOLOR="\033[0m"

###############################################################################
# Wrapper function to more easily output an error message to STDERR.
#
# Arguments:
#   The message to echo to STDERR.
#
# Outputs:
#   An ANSI colour code formatted message to print to STDERR based on
#   the message which is passed to the function as a parameter.
###############################################################################
function error() {
  echo -e "${RED}[ERROR]${NOCOLOR} $1"
}

###############################################################################
# Wrapper function to easily print a warning to STDOUT.
#
# Arguments:
#   The message to echo to STDOUT.
#
# Outputs:
#   An ANSI colour code formatted message to print to STDOUT based on
#   the message which is passed to the function as a parameter.
###############################################################################
function warn() {
  echo -e "${YELLOW}[WARN]${NOCOLOR} $1"
}

###############################################################################
# Wrapper function to easily print a success to STDOUT.
#
# Arguments:
#   The message to echo to STDOUT.
#
# Outputs:
#   An ANSI colour code formatted message to print to STDOUT based on
#   the message which is passed to the function as a parameter.
###############################################################################
function success() {
  echo -e "${GREEN}[SUCCESS]${NOCOLOR} $1"
}

###############################################################################
# Wrapper function to easily print a success to STDOUT.
#
# Arguments:
#   The message to echo to STDOUT.
#
# Outputs:
#   An ANSI colour code formatted message to print to STDOUT based on
#   the message which is passed to the function as a parameter.
###############################################################################
function info() {
  echo -e "${BLUE}[INFO]${NOCOLOR} $1"
}

###############################################################################
# Remove all unnecessary artifacts created by the script upon
# successful execution.
#
# Arguments:
#   None
#
# Outputs:
#   None
###############################################################################
function cleanup() {
  rm --recursive --force yay
}

#####################################################################
# Detect the OS the system is running and return the name of the OS
#
# Arguments:
#   None
#
# Outputs:
#   None
#####################################################################
function detect_os() {
  case "$(uname --all)" in
    *Microsoft*) readonly os="WSL" ;;
    *Linux*) if [[ -f "/etc/os-release" ]]; then
      source /etc/os-release
      readonly os="$NAME"
    else
      readonly os="Linux"
    fi ;;
    *Darwin*) readonly os="MacOS" ;;
    *) readonly os="" ;;
  esac
}

#####################################################################
# Detect the OS and perform a preliminary system update using the
# OS's native package manager
#
# Arguments:
#   None
#
# Outputs:
#   None
#####################################################################
function update_system() {
  # Fetch the name of the OS for further logic and conditions
  detect_os

  case "$os" in
    "WSL" | "Ubuntu") apt-get update --yes && apt-get upgrade ;;
    "MacOS") softwareupdate --install --all ;;
    "Fedora") dnf update && dnf upgrade ;;
    "Arch Linux") pacman --sync --upgrades --refresh ;;
    *) error "Unsupported or unknown OS. Unable to update system!" ;;
  esac
}

#####################################################################
# Detect the name of the OS and install some essentials programs
# using the OS's native package manager
#
# Arguments:
#   None
#
# Outputs:
#   None
#####################################################################
function install_essentials() {
  # Fetch the name of the OS for further logic and conditions
  detect_os

  # Logic to install the necessary essential programs
  case "$os" in
    "WSL" | "Ubuntu") apt-get install --yes git curl ca-certificates gnupg ;;
    "Fedora") dnf install git ;;
    "Arch Linux") pacman --sync --refresh --noconfirm base-devel git ;;
    *) error "Unsupported or unknown OS. Unable to update system!" ;;
  esac
}

#####################################################################
# Detect the OS name and install the "yay" package manager only if
# the system is running on an Arch Linux based OS
#
# Arguments:
#   None
#
# Outputs:
#   None
#####################################################################
function install_yay() {
  # Clone the "yay" git repository and run its installer
  git clone "https://aur.archlinux.org/yay.git"
  cd yay && makepkg -si --noconfirm && cd -
}

#####################################################################
# Install Homebrew using the installation script in a Bash subshell
#
# Arguments:
#   None
#
# Outputs:
#   None
#####################################################################
function install_homebrew() {
  # Homebrew installation script
  homebrew_url="https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh"

  # Fetch the installation script and invoke it in a subshell
  bash -c "$(curl --fail --silent --show-error --location $homebrew_url)"
}

#####################################################################
# Install Flatpak using the OS's native package manager
#
# Arguments:
#   None
#
# Outputs:
#   None
#####################################################################
function install_flatpak() {
  readonly flatpak_repo="https://flathub.org/repo/flathub.flatpakrepo"

  # Install flatpak using APT (which is the native package manager
  # for Debian/Ubuntu based OSes)
  apt-get install flatpak

  # Configure the repository to fetch the programs from using Flatpak
  flatpak remote-add --if-not-exists flathub "$flatpak_repo"
}

#####################################################################
# Download and setup the fonts for further installation
#
# Arguments:
#   None
#
# Outputs:
#   None
#####################################################################
function install_fonts() {
  readonly cascadia_code_download_url="https://github.com/ryanoasis/nerd-fonts/releases/download/v3.0.2/CascadiaCode.zip"
  readonly cascadia_code_zip_filename="cascadia_code.zip"

  # Download the zipped files
  curl --fail --silent --show-error --location --output \
    $cascadia_code_zip_filename $cascadia_code_download_url

  if [[ -d $cascadia_code_zip_filename ]]; then
    # Extract the contents of the downloaded zip file
    unzip $cascadia_code_zip_filename -d cascadia

    # Move the extracted font assets to its appropriate location
    mv cascadia/*.ttf "$HOME/.fonts"
  fi

  # Ensure the system is aware of the loaded fonts
  fc-cache --force --verbose
}

#####################################################################
# Install Homebrew packages based on the type of the OS used which is
# either Ubuntu or MacOS.
#
# Arguments:
#   None
#
# Outputs:
#   None
#####################################################################
function install_homebrew_packages() {
  # Taps are "repositories" to download the packages from
  readonly taps=(
    "eth-p/software" "go-task/tap" "homebrew/bundle" "homebrew/core"
  )

  # Casks are GUI tools (some proprietary) which can't be installed on
  # Linuxbrew
  readonly casks=(
    "visual-studio-code" "spotify" "discord" "inkscape" "dbeaverlite"
  )

  # The formulae are mostly CLI tools easily installable through
  # Linuxbrew
  readonly formulae=(
    "act" "azure-cli" "btop" "cmatrix" "exa" "fd" "gcc" "gh" "glow" "httpie"
    "lua@5.1" "mdbook" "neofetch" "neovim" "oci-cli" "poetry" "pre-commit"
    "ripgrep" "rustup-init" "starship" "shellcheck" "stow" "zsh"
  )

  # Setup the Homebrew taps
  for tap in "${taps[@]}"; do
    brew install "$tap"
  done

  # Detect the OS name for further conditional logic
  detect_os

  # Install only the formulae if the detected OS is Ubuntu/Debian
  if [[ "$os" == "Ubuntu" && ! "$os" == "MacOS" ]]; then
    for formula in "${formulae[@]}"; do
      brew install "$formula"
    done
  fi

  # Install both the formulae and the casks for MacOS
  if [[ "$os" == "MacOS" ]]; then
    # Loop through the "formulae" array to install the CLI tools
    for formula in "${formulae[@]}"; do
      brew install "$formula"
    done

    # Loop through the "casks" array to install the GUI tools
    for cask in "${casks[@]}"; do
      brew install "$cask"
    done
  fi
}

#####################################################################
# Install packages for Arch Linux based distributions from the Arch
# User Repository (AUR)
#
# Arguments:
#   None
#
# Outputs:
#   None
#####################################################################
function install_aur_packages() {
  # FIXME: List of some missing packages - "pre-commit"

  readonly aur_packages=(
    "act" "azure-cli" "btop-git" "cmatrix-git" "exa-git" "fd-git"
    "gcc11" "github-cli-git" "glow-git" "mdbook-git" "neofetch-gitn"
    "neovim-git" "oci-cli" "python-poetry-git" "ripgrep-git"
    "rustup-git" "starship-git" "shellcheck-bin" "stow-git" "zsh"
    "zsh-completions"
  )

  readonly pacman_packages=("httpie")

  # Check if "yay" is installed then install the programs mentioned
  # above
  if [[ -x $(command -v yay --version &>/dev/null) ]]; then
    for package in "${aur_packages[@]}"; do
      yay --sync --refresh --upgrade "$package"
    done
  else
    error "Failed to install packages from AUR!"
  fi

  # Install the pacman packages if any are required
  if [[ ! ${#pacman_packages[@]} -eq 0 ]]; then
    for package in "${pacman_packages[@]}"; do
      yay --sync --refresh --upgrade "$package"
    done
  else
    error "Failed to install Pacman packages!"
  fi
}

#####################################################################
# Entrypoint of the script to invoke with all the arbitrary
# parameters the script can be invoked with.
#
# Arguments:
#   None
#
# Outputs:
#   None
#####################################################################
function main() {
  # Fetch the OS name for certain conditional logic down the line
  detect_os

  info "Updating system..."
  # update_system

  info "Installing some essential programs..."
  # install_essentials

  # TODO: Consider cloning the remote dotfiles repository and then
  # executing the rest of the commands inside that local directory

  # Install "yay" package manager to install programs from AUR for
  # Arch Linux based OSes
  if [[ "$os" == "Arch Linux" ]]; then
    info "Installing \"yay\"..."
    # install_yay
  fi

  # Install "Homebrew" package manager for Ubuntu and MacOS
  if [[ "$os" == "Ubuntu" || "$os" == "MacOS" ]]; then
    info "Installing \"Homebrew\"..."
    # install_homebrew
  fi

  # Install Flatpak for Debian/Ubuntu based OSes since Fedora comes
  # preinstalled with Flatpak!
  if [[ "$os" == "Ubuntu" && ! $(command -v flatpak --version &>/dev/null) ]]; then
    info "Installing \"Flatpak\"..."
    # install_flatpak
  fi

  if [[ ! "$os" == "WSL" ]]; then
    info "Installing fonts (Cascadia Code)..."
    # install_fonts
  fi

  if [[ -x $(command -v brew --version &>/dev/null) ]]; then
    info "Installing Homebrew packages..."
    # install_homebrew_packages
  fi

  if [[ "$os" == "Arch Linux" && -x $(command -v yay --version &>/dev/null) ]]; then
    info "Installing AUR packages..."
    # install_aur_packages
  fi

  # TODO: Install the RPM packages for Fedora
  # TODO: Install the ZSH plugins
  # TODO: Install the GitHub CLI plugins
  # TODO: Download and setup the dotfiles on the system properly
  # TODO: Setup SSH for the system
  # TODO: Download and install Node.js, Rust, Docker
  # TODO: Share some notes on some manual tasks to perform after the setup is complete
}

# Prompt for sudo password and store its exit code for further usage
sudo -v
sudo_exit_code=$?

# Check if sudo credentials are cached then invoke the script to run
if [ "$sudo_exit_code" -eq 0 ]; then
  info "Setting up automated system setup now..."
  main
  success "Automated system setup is complete..."
else
  warn "Sudo privileges are required to run this script!"
fi

# Cleanup any generated artifacts and the system in general after the
# scripts completes execution
trap cleanup EXIT
